# 정규화

## 중복된 데이터 반드시 정규화 해야하는 건가?

정규화도 비용이다. 읽기 비용을 지불하고 쓰기 비용을 줄이는 것.

## 정규화 시 고려해야 할 것

얼마나 빠르게 데이터의 최신성을 보장해야 하는가?

히스토리성 데이터는 오히려 정규화를 하지 않아야 한다.

데이터 변경 주기와 조회 주기는 어떻게 되는가?

객체(테이블) 탐색 깊이가 얼마나 깊은가?
<br/><img src="/img/p1_1.png"><br/>
=> 이 경우도 결국 읽기 성능을 위해 쓰기 성능을 어느정도 포기한 것.

## 정규화를 하기로 했다면 읽기 시 데이터를 어떻게 가져올 것인가?

테이블 조인을 많이 활용하는데 조인은 서로 다른 테이블의 결합도를 엄청나게 높인다.
조회 시에는 성능이 좋은 별도 데이터베이스나 캐싱 등 다양한 최적화 기법을 이용할 수 있다.
조인을 사용하게 되면 이런 기법들을 사용하는데 제한이 있거나 더 많은 리소스가 들 수 있다.
읽기 쿼리 한 번 더 발생되는 것은 그렇게 큰 부담이 아닐 수도 있다.

그렇다고 조인이 항상 안 좋은 것은 아님. 장단점을 잘 파악 후 적용하자.

# 데이터베이스 성능 핵심

데이터베이스의 데이터는 결국 디스크에 저장됨.
결국 데이터베이스 성능의 핵심은 디스크 I/O(접근)을 최소화 하는 것.
어떻게?<br/>
=> 메모리에 올라온 데이터로 최대한 요청을 처리하는 것(메모리 캐시 히트율을 높이는 것).

데이터베이스에 insert, update 등을 할 때 바로 디스크에 쓰지 않고 메모리에 씀.<br/>
=> 메모리 데이터 유실을 고려해 WAL(Write Ahead Log) 사용.

대부분의 트랜잭션은 무작위하게 Write가 발생.<br/>
=> 이를 지연시켜 랜덤 I/O 횟수를 줄이는 대신 순차적으로 I/O를 발생시켜 정합성 유지.
즉 데이터베이스는 insert나 update를 메모리에 쌓아놨다가 어느정도 쌓이면 한 번에 디스크에 write 함.
근데 이 메모리에 있던 데이터가 디스크로 가기 전에 서버가 죽어버리면 어떡하지?<br/>
=> WAL 기술 사용.
쿼리의 로그가 남아 메모리 데이터가 유실되더라도 서버 재실행 시 이 로그를 보고 재실행

다시 말해보면 데이터베이스 성능의 핵심은 디스크의 랜덤 I/O(접근)을 최소화 하는 것.

# 인덱스

인덱스는 정렬된 자료구조, 이를 통해 탐색 범위를 최소화<br/>
=> 테이블이 추가됨.<br/>
=> 조회의 성능은 좋아지지만 쓰기/갱신의 성능은 낮아짐. 균형을 잘 맞춰야 함.

탐색(검색)이 빠른 자료 구조들은 어떤 것이 있을까?

- HashMap<br/>
  단건 검색 속도 O(1)<br/>
  그러나 범위 탐색은 O(N)<br/>
  전방 일치 탐색 불가 ex: like 'AB%'

- List<br/>
  정렬되지 않은 리스트의 탐색은 O(N)<br/>
  정렬된 리스트의 탐색은 O(logN)<br/>
  정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(N \* logN)<br/>
  삽입 / 삭제 비용이 매우 높음

- Tree<br/>
  트리 높이에 따라 시간 복잡도가 결정됨<br/>
  트리의 높이를 최소화하는 것이 중요<br/>
  한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용<br/>
  ex: Red-Black Tree, B+ Tree

대부분의 RDBMS에서는 B+ Tree를 사용 왜?<br/>
삽입 / 삭제 시 항상 균형을 이룸<br/>
하나의 노드가 여러 개의 자식 노드를 가질 수 있음<br/>
리프노드에만 데이터 존재<br/>
(마지막 노드에만 데이터가 존재하고 그 위의 노드들에는 데이터를 찾아가기 위한 키가 됨)<br/>
=> 연속적인 데이터 접근 시 유리, 각 노드 접근 시 데이터를 직접 조회하는 것이 아님

BPlus Tree 데이터 삽입/삭제 시각화<br/>
<https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>

MySQL의 경우 인덱스에 PK가 있음 but Oracle은 인덱스에 해당 데이터 주소가 있음

## 클러스터 인덱스

1. 클러스터 인덱스는 데이터 위치를 결정하는 키 값이다.<br/>
   클러스터 키 순서에 따라서 데이터 저장 위치가 변경된다.<br/>
   클러스터 키 삽입/갱신 시 성능 이슈 발생.

2. MySQL의 PK는 클러스터 인덱스다.<br/>
   PK 순서에 따라 데이터 저장 위치가 변경된다.<br/>
   PK 키 삽입/갱신 시 성능 이슈 발생.

3. MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.<br/>
   PK의 사이즈가 인덱스의 사이즈를 결정.<br/>
   세컨더리 인덱스만으로는 데이터를 찾아갈 수 없다.<br/>
   PK 인덱스를 항상 검색해야 함.

### 클러스터 인덱스의 장정

1. PK를 활용한 검색이 빠름. 특히 범위 검색.

2. 세컨더리 인덱스들이 PK를 가지고 있어 커버링에 유리.

<br/><img src="/img/p1_2.png">
<br/><img src="/img/p1_3.png"><br/>

PK로 Auto Increment / UUID 각 장단점? 찾아보기</br></br>

- auto_increment
  장점: 빠름</br>사람이 보기 쉬움</br>
  단점: 분산 시스템에 적합하지 않음(서로 다른 DB에 저장하는 경우 key가 같은 데이터를 처리하는 문제)</br>키 예측 쉬움

- UUID
  장점: UUID를 어디서든지 만들고 고유성을 보장할 수 있어 분산 시스템에 용이</br>
  단점: 성능 저하(클러스터 인덱스의 정렬 비용 증가)</br>사람이 보기 어려움</br>필요 이상으로 많은 공간 차지</br></br>

95%의 상황에서는 Increment PK를 사용해야하고 보조키로 UUID를 사용하는게 대안이라고 한다.</br>
나머지 5%의 상황은 UUID를 기본키로 사용하는 것인데 그렇게 하는 이유는 데이터베이스 병합 시에 키 충돌 문제가 발생할 것 같을때만 쓰라고 한다.(극히 드물다)</br>

결론적으로는 가장 이상적인 솔루션은 PK를 UUID로 사용하고 절대 외부로 노출 시키지 않는 것이라고 한다.</br>
하지만 말 그대로 이상적이기 때문에 그렇게 하면 제대로 개발을 할 수 없다. PK 자체를 외부로 꺼내지 않으면 API 요청을 할 수 없기 때문이다.</br>

그렇기에 실무에서는 Increment와 UUID를 같이 쓰거나 Increment만을 쓰는 것을 고려하는 것이 좋다.</br>

참고 링크:</br>
<a href="https://stir.tistory.com/294" target="_blank">tistory-stir</a></br>
<a href="https://velog.io/@gwichanlee/DB-MySQL-Auto-increment-vs-UUID#:~:text=MySQL%EC%97%90%EC%84%9C%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%20%ED%82%A4%EB%A5%BC,%EA%B0%80%20%EA%B3%84%EC%86%8D%20%EB%B0%80%EB%A6%B4%20%EC%88%98%20%EC%9E%88%EB%8B%A4." target="_blank">velog-gwichanlee</a>

## 인덱스를 다룰 때 주의해야 할 점

1. 인덱스 필드 가공</br>

인덱스 필드를 가공하면 인덱스를 탈 수 없다.</br>
ex:

```
select * from member where age * 10 = 1(가공)
select * from member where age = '1'(타입 불일치)
```

2. 복합 인덱스</br>

<br/><img src="/img/p1_5.png"><br/>

여기서 만약 where문에 원산지만 들어오면 인덱스를 탈 수 없다. 왜?</br>
원산지만 보면 정렬되어있지 않은 정보이기 때문.</br>
하지만 where문에 과일만 들어와도 인덱스를 탈 수 있다. 정렬되어있기 때문.</br>
그래서 복합 인덱스 설정 시 맨 앞 즉, 선두 컬럼을 무엇으로 할지가 매우 중요.</br>

3. 하나의 쿼리에는 하나의 인덱스만</br>

여러 인덱스 테이블을 동시에 탐색하지 않는다.</br>
5개의 인덱스를 걸어도 옵티마이저가 하나만 선택한다.</br>
where, order by, group by 등 혼합해서 사용할 때는 인덱스를 잘 고려해야 한다.</br>

4. 기타</br>

- 의도대로 인덱스가 동작하지 않을 수도 있다. explain으로 확인.</br>
  개발 환경과 실제 배포 환경의 데이터가 다를 수 있다.</br>

- 인덱스도 비용이다. 쓰기 성능 희생하고 조회 성능을 얻는 것.</br>

- 꼭 인덱스만으로 해결할 수 있는 문제인가?</br>

- 인덱스는 데이터의 식별정도가 높은 것으로 하는 게 좋다.</br>

# 페이지네이션

많은 양의 데이터를 어떻게 노출할 것인가?</br>
게시판에서 주로 사용하는 다음 페이지 방식 vs SNS에서 주로 사용하는 스크롤 방식</br>

## 문제점

20개의 게시물 존재, 10개씩 페이징을 한다고 할 때 2번 페이지를 요청하면 데이터베이스는 1번 페이지도 스캔함</br>
마지막 페이지를 구하기 위해 전체 데이터 수를 알아야 함.</br>
