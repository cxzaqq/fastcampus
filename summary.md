# 정규화

## 중복된 데이터 반드시 정규화 해야하는 건가?

정규화도 비용이다. 읽기 비용을 지불하고 쓰기 비용을 줄이는 것.

## 정규화 시 고려해야 할 것

얼마나 빠르게 데이터의 최신성을 보장해야 하는가?

히스토리성 데이터는 오히려 정규화를 하지 않아야 한다.

데이터 변경 주기와 조회 주기는 어떻게 되는가?

객체(테이블) 탐색 깊이가 얼마나 깊은가?
<br/><img src="/img/p1_1.png"><br/>
=> 이 경우도 결국 읽기 성능을 위해 쓰기 성능을 어느정도 포기한 것.

## 정규화를 하기로 했다면 읽기 시 데이터를 어떻게 가져올 것인가?

테이블 조인을 많이 활용하는데 조인은 서로 다른 테이블의 결합도를 엄청나게 높인다.
조회 시에는 성능이 좋은 별도 데이터베이스나 캐싱 등 다양한 최적화 기법을 이용할 수 있다.
조인을 사용하게 되면 이런 기법들을 사용하는데 제한이 있거나 더 많은 리소스가 들 수 있다.
읽기 쿼리 한 번 더 발생되는 것은 그렇게 큰 부담이 아닐 수도 있다.

그렇다고 조인이 항상 안 좋은 것은 아님. 장단점을 잘 파악 후 적용하자.

# 데이터베이스 성능 핵심

데이터베이스의 데이터는 결국 디스크에 저장됨.
결국 데이터베이스 성능의 핵심은 디스크 I/O(접근)을 최소화 하는 것.
어떻게?<br/>
=> 메모리에 올라온 데이터로 최대한 요청을 처리하는 것(메모리 캐시 히트율을 높이는 것).

데이터베이스에 insert, update 등을 할 때 바로 디스크에 쓰지 않고 메모리에 씀.<br/>
=> 메모리 데이터 유실을 고려해 WAL(Write Ahead Log) 사용.

대부분의 트랜잭션은 무작위하게 Write가 발생.<br/>
=> 이를 지연시켜 랜덤 I/O 횟수를 줄이는 대신 순차적으로 I/O를 발생시켜 정합성 유지.
즉 데이터베이스는 insert나 update를 메모리에 쌓아놨다가 어느정도 쌓이면 한 번에 디스크에 write 함.
근데 이 메모리에 있던 데이터가 디스크로 가기 전에 서버가 죽어버리면 어떡하지?<br/>
=> WAL 기술 사용.
쿼리의 로그가 남아 메모리 데이터가 유실되더라도 서버 재실행 시 이 로그를 보고 재실행

다시 말해보면 데이터베이스 성능의 핵심은 디스크의 랜덤 I/O(접근)을 최소화 하는 것.

# 인덱스

인덱스는 정렬된 자료구조, 이를 통해 탐색 범위를 최소화<br/>
=> 테이블이 추가됨.<br/>
=> 조회의 성능은 좋아지지만 쓰기/갱신의 성능은 낮아짐. 균형을 잘 맞춰야 함.

탐색(검색)이 빠른 자료 구조들은 어떤 것이 있을까?

- HashMap<br/>
  단건 검색 속도 O(1)<br/>
  그러나 범위 탐색은 O(N)<br/>
  전방 일치 탐색 불가 ex: like 'AB%'

- List<br/>
  정렬되지 않은 리스트의 탐색은 O(N)<br/>
  정렬된 리스트의 탐색은 O(logN)<br/>
  정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(N \* logN)<br/>
  삽입 / 삭제 비용이 매우 높음

- Tree<br/>
  트리 높이에 따라 시간 복잡도가 결정됨<br/>
  트리의 높이를 최소화하는 것이 중요<br/>
  한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용<br/>
  ex: Red-Black Tree, B+ Tree

대부분의 RDBMS에서는 B+ Tree를 사용 왜?<br/>
삽입 / 삭제 시 항상 균형을 이룸<br/>
하나의 노드가 여러 개의 자식 노드를 가질 수 있음<br/>
리프노드에만 데이터 존재<br/>
(마지막 노드에만 데이터가 존재하고 그 위의 노드들에는 데이터를 찾아가기 위한 키가 됨)<br/>
=> 연속적인 데이터 접근 시 유리, 각 노드 접근 시 데이터를 직접 조회하는 것이 아님

BPlus Tree 데이터 삽입/삭제 시각화<br/>
<https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html>

MySQL의 경우 인덱스에 PK가 있음 but Oracle은 인덱스에 해당 데이터 주소가 있음

## 클러스터 인덱스

1. 클러스터 인덱스는 데이터 위치를 결정하는 키 값이다.

클러스터 키 순서에 따라서 데이터 저장 위치가 변경된다.<br/>
클러스터 키 삽입/갱신 시 성능 이슈 발생.

2. MySQL의 PK는 클러스터 인덱스다.

PK 순서에 따라 데이터 저장 위치가 변경된다.<br/>
PK 키 삽입/갱신 시 성능 이슈 발생.

PK로 Auto Increment / UUID 각 장단점?

3. MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.

PK의 사이즈가 인덱스의 사이즈를 결정.
세컨더리 인덱스만으로는 데이터를 찾아갈 수 없다.<br/>
PK 인덱스를 항상 검색해야 함.

### 클러스터 인덱스의 장정

1. PK를 활용한 검색이 빠름. 특히 범위 검색.

2. 세컨더리 인덱스들이 PK를 가지고 있어 커버링에 유리.

<br/><img src="/img/p1_2.png">
<br/><img src="/img/p1_3.png"><br/>
